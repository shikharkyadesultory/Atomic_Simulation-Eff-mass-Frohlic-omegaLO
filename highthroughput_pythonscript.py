# -*- coding: utf-8 -*-
"""HighThroughput_Pythonscript.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-3RWUZuNlHk89ATq5WGlkyH2-YiPjsDf
"""

!pip install ase

!apt-get update
!apt-get install -y build-essential libfftw3-dev libxc-dev

from google.colab import drive
drive.mount('/content/drive')

import sys
print(sys.path)

!pip3 install gpaw

import sys
!{sys.executable} -m pip install --upgrade --no-cache-dir --prefix /usr/local gpaw

!which gpaw

import sys
import os
import subprocess

# Find gpaw using which command
try:
    gpaw_exec = subprocess.check_output(['which', 'gpaw']).decode().strip()
except subprocess.CalledProcessError:
    raise FileNotFoundError("Could not locate the gpaw executable. "
                            "Please make sure gpaw is installed and in your PATH.")
gpaw_data_dir = '/usr/local/lib/python3/dist-packages/gpaw/data'

# Create the directories if they don't exist:
os.makedirs(gpaw_data_dir, exist_ok=True)

!{gpaw_exec} install-data {gpaw_data_dir}

!gpaw info

!pip install --q ase gpaw

!wget -q https://wiki.fysik.dtu.dk/gpaw-files/gpaw-setups-24.11.0.tar.gz
!tar -xzf gpaw-setups-24.11.0.tar.gz

import os
os.environ["GPAW_SETUP_PATH"] = "/content/gpaw-setups-24.11.0"

"""# **Autom_ate DevOp**"""

######## Importing Necessary Libraries ###########
from ase.build import mx2, add_adsorbate
from ase.constraints import FixAtoms
from gpaw import GPAW, PW
from ase.io import write
import numpy as np
import time
from google.colab import drive  # For Google Colab integration

class HighThroughputAutomation:
    def __init__(self):
        """Initialize the high-throughput automation system"""
        self.primary_functions = {
            '1': {'name': 'Adsorption', 'function': self.adsorption},
            '2': {'name': 'Substitution', 'function': self.substitution},
            '3': {'name': 'Defect', 'function': self.defect},
        }

    def run(self):
        """Main execution loop"""
        while True:
            self._display_main_menu()
            choice = input("Enter your choice (1-3, or 0 to exit): ")

            if choice == '0':
                print("Exiting program...")
                time.sleep(2)
                print("\nYour Choice defines you")
                break

            if choice in self.primary_functions:
                self.primary_functions[choice]['function']()
            else:
                print("Invalid choice. Please try again.")

    def _display_main_menu(self):
        """Display the main menu options"""
        print("\n" + "="*40)
        print("High-Throughput Materials Automation")
        print("="*40)
        for key, value in sorted(self.primary_functions.items()):
            print(f"{key}. {value['name']}")
        print("0. Exit")
        print("="*40)

    def adsorption(self):
        """Perform adsorption calculations and return CIF file paths"""
        a = 4  # Guess value of 4Å
        print("\n=== Adsorption Calculation ===")


        Trans_met = input("Enter the Transition metal in TMDC").strip()
        Chalc_met = input("Enter the chalcogen symbol in the base material (e.g., S, Se, Te): ").strip()
        adsorbate = input("Enter the adsorbate material (e.g., Au, Pt, Bi): ").strip()
        base_material = input("Enter the 2D base material formula (e.g., ZrS2): ").strip()
        kind_in = input("Enter the space group (e.g., P6m2): ").strip()

        num_configs = int(input("How many different adsorption configurations to try? "))

        output_files = []

        for config in range(num_configs):
            try:
                print(f"\nProcessing ..... Bro Just Chill {config+1}...")

                slab = mx2(formula=base_material, kind=kind_in, a=a,
                          thickness=3.5, vacuum=15)
                slab = slab.repeat((3, 3, 1))
                slab.center(vacuum=15, axis=2)

                s_positions = [atom.position for atom in slab if atom.symbol == Chalc_met]
                if not s_positions:
                    raise ValueError(f"No {Chalc_met} atoms found in structure")

                print(f"\nAvailable {Chalc_met} positions for adsorption:")
                for i, pos in enumerate(s_positions[:5]):  # Show first 5 positions
                    print(f"{i+1}: (x={pos[0]:.2f}, y={pos[1]:.2f})")

                site_choice = int(input(f"Choose adsorption site (1-{min(5,len(s_positions))}): ")) - 1
                adsorption_site = s_positions[site_choice][:2]

                add_adsorbate(slab, adsorbate, height=4, position=adsorption_site)

                z_mean = np.mean([atom.z for atom in slab if atom.symbol in adsorbate.split()])
                fixed_indices = [atom.index for atom in slab if atom.position[2] < z_mean]
                slab.set_constraint(FixAtoms(indices=fixed_indices))

                calc = GPAW(
                    mode=PW(400),
                    xc='PBE',
                    kpts={'size': (4, 4, 1), 'gamma': True},
                    txt=f'{adsorbate}_on_{base_material}_config{config+1}.log'
                )
                slab.calc = calc

                filename = f'/content/{adsorbate}_{base_material}_adsorption.cif'
                write(filename, slab)
                print(f"Saved: {filename}")
                output_files.append(filename)

            except Exception as e:
                print(f"Error in configuration {config+1}: {str(e)}")
                output_files.append(None)

        print("\nAdsorption calculation complete!")
        time.sleep(2)
        print("\nA L E R T -> BRO stress your fings, do a SOC Optimize on VASP")
        return output_files

    def substitution(self):
      a = 4  # Guess value of Lattice parameter 4Å
      print("\n=== Substitution Calculations ===")
      Trans_met = input("Enter the Transition metal in the TMDC: ").strip()
      Chalc_met = input("Enter the chalcogen symbol in the base material (e.g., S, Se, Te): ").strip()
      substitute = input("Enter the substitution atom (e.g., Au, Pt, Bi): ").strip()
      base_material = input("Enter the 2D base material formula (e.g., ZrS2): ").strip()
      kind_in = input("Enter the space group (e.g. 1T): ").strip()

      num_configs = int(input("Enter the number of different substitution configurations to try: "))

      output_files = []
      for config in range(num_configs):
          try:
              print(f"\nProcessing configuration {config+1}...")

              slab = mx2(formula=base_material, kind=kind_in, a=a, thickness=3.5, vacuum=15)
              slab = slab.repeat((3, 3, 1))
              slab.center(vacuum=15, axis=2)

              t_indices = [atom.index for atom in slab if atom.symbol == Trans_met]
              if not t_indices:
                  raise ValueError(f"No atoms with symbol '{Trans_met}' found")

              t_positions = [slab[i].position for i in t_indices]

              print(f"\nAvailable {Trans_met} positions for substitution:")
              for i, pos in enumerate(t_positions[:9]):  # Show first 9 positions
                  print(f"{i+1}: (x={pos[0]:.4f}, y={pos[1]:.4f}, z={pos[2]:.4f})")

              site_choice = int(input(f"Choose a site (1-{len(t_positions)}): ")) - 1
              sub_index = t_indices[site_choice]  # Get the actual atom index

              slab[sub_index].symbol = substitute

              z_mean = np.mean([atom.z for atom in slab if atom.symbol == substitute])
              fixed_indices = [atom.index for atom in slab if atom.position[2] < z_mean]
              slab.set_constraint(FixAtoms(indices=fixed_indices))

              # Setup calculator
              calc = GPAW(
                  mode=PW(400),
                  xc='PBE',
                  kpts={'size': (4, 4, 1), 'gamma': True},
                  txt=f'{substitute}_substituted_{base_material}_{config+1}.log'
              )
              slab.calc = calc

              filename = f"/content/{substitute}_{base_material}_substituted.cif"
              write(filename, slab)
              print(f"Successfully saved: {filename}")
              output_files.append(filename)

          except Exception as e:
              print(f"Error in configuration {config+1}: {str(e)}")
              output_files.append(None)
          time.sleep(1)
          print("\nSubstitution Complete without you writing a single line of code")
          time.sleep(2)
          print("\nHaving fun ...... just remember one thing .......")
          time.sleep(2)
          print("\nA L E R T -> Have the cif files SOC optimized in VASP")
          return output_files

    def defect(self):
      """Create chalcogen vacancy and substitute with another atom"""
      a = 4  # Lattice parameter guess value (Angstrom)
      print("\n=== Defect and Substitution Calculations ===")

      Trans_met = input("Enter the Transition metal in the TMDC: ").strip()
      Chalc_met = input("Enter the chalcogen symbol in the base material (e.g., S, Se, Te): ").strip()
      substitute = input("Enter the substitution material (e.g., Au, Pt, Bi): ").strip()
      base_material = input("Enter the 2D base material formula (e.g., ZrS2): ").strip()
      kind_in = input("Enter the space group (e.g. 1T): ").strip()
      num_configs = int(input("Enter number of defect configurations to try: "))

      output_files = []
      for config in range(num_configs):
          try:
              print(f"\nProcessing configuration {config+1}/{num_configs}")

              slab = mx2(formula=base_material, kind=kind_in, a=a, thickness=3.5, vacuum=15)
              slab = slab.repeat((3, 3, 1))
              slab.center(vacuum=15, axis=2)

              s_indices = [atom.index for atom in slab if atom.symbol == Chalc_met]
              if not s_indices:
                  raise ValueError(f"No {Chalc_met} atoms found in structure")

              print(f"\nAvailable {Chalc_met} positions:")
              for i, idx in enumerate(s_indices[:9]):
                  pos = slab[idx].position
                  print(f"{i+1}: (x={pos[0]:.4f}, y={pos[1]:.4f}, z={pos[2]:.4f})")

              site_choice = int(input(f"Choose site (1-{len(s_indices)}): ")) - 1
              defect_idx = s_indices[site_choice]
              defect_pos = slab[defect_idx].position.copy()

              del slab[defect_idx]
              print(f"\nCreated {Chalc_met} vacancy at position {defect_pos[:2]}")

              slab.append(substitute)
              slab[-1].position = defect_pos
              print(f"Added {substitute} atom at vacancy site")

              z_mean = np.mean([atom.z for atom in slab if atom.symbol == substitute])
              fixed_indices = [atom.index for atom in slab if atom.position[2] < z_mean]
              slab.set_constraint(FixAtoms(indices=fixed_indices))

              calc = GPAW(
                  mode=PW(400),
                  xc='PBE',
                  kpts={'size': (4, 4, 1), 'gamma': True},
                  txt=f'{substitute}_substituted_{base_material}_{config+1}.log'
              )
              slab.calc = calc

              defect_filename = f"/content/{base_material}_{Chalc_met}vacancy_config{config+1}.cif"
              substitute_filename = f"/content/{substitute}_{base_material}_defsub.cif"

              temp_slab = slab.copy()
              del temp_slab[-1]
              write(defect_filename, temp_slab)

              write(substitute_filename, slab)

              print(f"\nSuccessfully created:")
              print(f"- Defect structure: {defect_filename}")
              print(f"- Substituted structure: {substitute_filename}")

              output_files.append((substitute_filename))

          except Exception as e:
              print(f"Error in configuration {config+1}: {str(e)}")
              output_files.append(None)
          time.sleep(1)
          print("\nDefect and Substitution Complete without you writing a single line of code")
          time.sleep(2)
          print("\nHaving fun ...... just remember one thing .......")
          time.sleep(2)
          print("\nA L E R T -> Have the cif files SOC optimized in VASP")

      print("\nAll calculations complete!")
      print("Remember to SOC optimize these structures in VASP")
      return output_files

# Main execution block
if __name__ == "__main__":
    # Mount Google Drive
    try:
        drive.mount('/content/drive')
        print("Google Drive mounted successfully!")
    except:
        print("Running in local mode (not Colab)")


    print("Initializing High-Throughput Automation System...")
    hta = HighThroughputAutomation()
    hta.run()